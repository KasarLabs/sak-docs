# Integrate Langchain Tools

Learn how to integrate and use Langchain tools with your Starknet agent.

## Understanding Langchain Integration

The Starknet Agent Kit uses Langchain as its foundation for AI capabilities. This integration allows you to:

- Create AI-powered tools for blockchain interactions
- Use natural language processing for command interpretation
- Chain multiple operations together
- Add custom reasoning capabilities

## Basic Integration

### Setting Up the Agent

```typescript
import { ChatPromptTemplate } from '@langchain/core/prompts';
import { createToolCallingAgent, AgentExecutor } from 'langchain/agents';
import { ChatAnthropic } from '@langchain/anthropic';

// Create prompt template
const prompt = ChatPromptTemplate.fromMessages([
  ['system', 'You are a helpful Starknet assistant...'],
  ['human', '{input}'],
  ['assistant', '{agent_scratchpad}']
]);

// Initialize AI model
const model = new ChatAnthropic({
  modelName: 'claude-3-5-sonnet-latest',
  anthropicApiKey: 'your-api-key'
});

// Create agent
const agent = createToolCallingAgent({
  llm: model,
  tools: yourTools,
  prompt
});

// Create executor
const executor = new AgentExecutor({
  agent,
  tools: yourTools
});
```

### Creating Langchain Tools

```typescript
import { tool } from '@langchain/core/tools';

const starknetTool = tool(
  async (params: any) => {
    // Tool implementation
    const result = await performOperation(params);
    return JSON.stringify(result);
  },
  {
    name: 'starknet_operation',
    description: 'Performs operations on Starknet',
    schema: operationSchema
  }
);
```

## Advanced Tool Patterns

### 1. Structured Tool Outputs

```typescript
import { StructuredTool } from '@langchain/core/tools';

class StarknetStructuredTool extends StructuredTool {
  name = 'starknet_structured';
  description = 'Structured Starknet operation';
  schema = z.object({
    operation: z.string(),
    parameters: z.record(z.unknown())
  });

  async _call(input: z.infer<typeof this.schema>) {
    // Implementation
    return structuredResult;
  }
}
```

### 2. Chain of Tools

```typescript
import { SimpleSequentialChain } from 'langchain/chains';

const toolChain = new SimpleSequentialChain({
  chains: [
    createBalanceCheckTool(),
    createTransferTool(),
    createVerificationTool()
  ]
});
```

### 3. Memory-Enabled Tools

```typescript
import { BufferMemory } from 'langchain/memory';

const memory = new BufferMemory();

const memoryEnabledTool = tool(
  async (params: any) => {
    // Get context from memory
    const context = await memory.loadMemoryVariables({});
    
    // Perform operation with context
    const result = await performOperation(params, context);
    
    // Save new context
    await memory.saveContext(
      { input: params },
      { output: result }
    );
    
    return JSON.stringify(result);
  },
  {
    name: 'memory_tool',
    description: 'Tool with memory capabilities'
  }
);
```

## Handling Tool Responses

### 1. Response Parsing

```typescript
const parseToolResponse = (response: string) => {
  try {
    const parsed = JSON.parse(response);
    
    if (parsed.status === 'success') {
      return {
        success: true,
        data: parsed.data
      };
    }
    
    return {
      success: false,
      error: parsed.error
    };
  } catch (error) {
    return {
      success: false,
      error: 'Failed to parse response'
    };
  }
};
```

### 2. Response Formatting

```typescript
const formatToolResponse = (result: any) => {
  if (result.transactionHash) {
    return `Transaction submitted! View it here: https://voyager.online/tx/${result.transactionHash}`;
  }
  
  return JSON.stringify(result, null, 2);
};
```

## Tool Categories

### 1. Information Tools

```typescript
const infoTool = tool(
  async (params: any) => {
    const provider = new RpcProvider(RPC_URL);
    const info = await provider.getInfo();
    return JSON.stringify(info);
  },
  {
    name: 'get_network_info',
    description: 'Get Starknet network information'
  }
);
```

### 2. Transaction Tools

```typescript
const txTool = tool(
  async (params: any) => {
    const account = new Account(provider, address, privateKey);
    const tx = await account.execute(params.calls);
    return JSON.stringify(tx);
  },
  {
    name: 'execute_transaction',
    description: 'Execute a Starknet transaction'
  }
);
```

### 3. Analysis Tools

```typescript
const analysisTool = tool(
  async (params: any) => {
    const analysis = await analyzeContract(params.address);
    return JSON.stringify(analysis);
  },
  {
    name: 'analyze_contract',
    description: 'Analyze a Starknet contract'
  }
);
```

## Best Practices

1. **Tool Documentation**
   - Provide clear descriptions
   - Include example inputs/outputs
   - Document error cases

2. **Error Handling**
   - Use try-catch blocks
   - Return structured error responses
   - Log errors appropriately

3. **Response Formatting**
   - Use consistent response structures
   - Include necessary metadata
   - Format for readability

4. **Testing**
   - Unit test each tool
   - Test error cases
   - Test tool chains

## Next Steps

- Explore [Wallet Management](/core-concepts/wallet-management)
- Learn about [Agent Actions](/core-concepts/agent-actions)
- Check our [API Reference](/reference/api-reference)